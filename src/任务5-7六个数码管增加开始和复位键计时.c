//功能：简易秒表设计，六个动态数码管，定时器采用查询方式
#include "reg51.h" //包含头文件reg51.h，定义了51单片机的专用寄存器
//全局变量定义
unsigned char count = 0; //全局变量，对50ms定时器T1进行计满溢出次数统计
unsigned char miao = 0;  //全局变量，可在所有函数中使用，其值为最后一次执行的结果，
                         //是1秒计数统计的变量
unsigned char fen = 0;   //全局变量，分钟统计的变量
unsigned char shi = 0;   //全局变量，小时统计的变量
bit b = 0;               //自定义一个全局位变量b，其值为0或者1
//函数名：timer_1()
//函数功能：定时器T1中断函数，假设T1在工作方式1下每50ms产生溢出中断
//形式参数：无
//返回值：无
void timer_1() interrupt 3 //50ms定时器T1进入的中断函数，中断序号为3，功能：定时器T1中断函数
{
    count++;                     //50ms定时器T1每隔50ms进入到这个中断函数，count用于统计进入的次数
    TH1 = (65536 - 50000) / 256; //重新设置T1计数初值高8位，不然定时器T1不会第二次重新开始计数
    TL1 = (65536 - 50000) % 256; //重新设置T1计数初值低8位
    if (count == 20)             //当执行了20次后，则表示1s时间到
    {
        count = 0; //当统计到20次时，将50ms的计数变量count清0
        miao++;    //1秒计数变量miao加1
        if (miao == 60)
        {
            miao = 0;      //当miao计数到60，则从0重新开始计数
            fen++;         //分钟fen开始加1
            if (fen == 60) //当分钟fen计数到60时，则从0重新开始计数
            {
                fen = 0;
                shi++; //小时shi开始加1
                if (shi == 24)
                    shi = 0; //当时钟shi计数到24时，则从0重新开始计数
            }
        }
    }
}

void delay(unsigned int i) //延时函数
{
    while (i--)
        ;
}

void disp() //数码管显示函数，注意括号内不带变量
{
    unsigned char code led[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
    //定义0～9显示码，共阴极数码管
    //秒部分的显示
    P2 = 0xff;           //关闭6个数码管
    P1 = led[miao % 10]; //显示秒miao低位，商放在右起第1个数码管
    P2 = 0xfe;           //只打开第1个数码管 P2=1111 1110=0xfe
    delay(50);           //延时5ms
    P2 = 0xff;
    P1 = led[miao / 10]; //显示秒miao高位，取余数放在右起第2个数码管
    P2 = 0xfd;           //只打开第2个数码管 P2=1111 1101=0xfd
    delay(50);
    //分钟部分的显示
    P2 = 0xff;          //关闭6个数码管
    P1 = led[fen % 10]; //显示分钟fen低位，商放在右起第3个数码管
    P2 = 0xfb;          //只打开第3个数码管 P2=1111 1011=0xfb
    delay(50);          //延时5ms
    P2 = 0xff;
    P1 = led[fen / 10]; //显示分钟fen高位，取余数放在右起第4个数码管
    P2 = 0xf7;          //只打开第4个数码管 P2=1111 0111=0xf7
    delay(50);
    //小时部分的显示
    P2 = 0xff;          //关闭6个数码管
    P1 = led[shi % 10]; //显示小时shi低位，商放在右起第5个数码管
    P2 = 0xef;          //只打开第5个数码管 P2=1110 1111=0xef
    delay(50);          //延时5ms
    P2 = 0xff;
    P1 = led[shi / 10]; //显示小时shi高位，取余数放在右起第6个数码管
    P2 = 0xdf;          //只打开第6个数码管 P2=1101 1111=0xdf
    delay(50);
}

void int_0() interrupt 0 //外部中断1的中断函数，中断序号为0，功能：按1下暂停，再按1下开始
{
    TR1 = ~TR1; //（6）启动T1开始计时，再次进入则停止计时
    /*下面是方法2，来实现按1下开始，再按1下暂停的效果
    if (b == 0) //第一次外部中断0时，b=0
    {
        TR1 = 0; //停止定时器T1
        b = 1;
    } //让b=1，这样再按一次外部中断0进来时，b是为1的
    else
    {
        b = 0; //把b清为0，这样第三次外部中断0进来时，b为0
        TR1 = 1;
    } //重新启动定时器T1
    */
}

void int_1() interrupt 2 //外部中断0的中断函数，中断序号为2，功能：按1下清零
{
    count = 0; //对50ms计数变量清零
    miao = 0;  //对秒计数变量清零
    fen = 0;   //对分钟计数变量清零
    shi = 0;   //对小时计数变量清零
}

void main() //主函数
{
    TMOD |= 0x10;                //设置定时器T1，工作方式1
    TH1 = (65536 - 50000) / 256; //设置定时器T1为50ms间隔中断，高8位赋初值，以便第一次50ms后进入定时器中断函数
    TL1 = (65536 - 50000) % 256; //设置定时器T1为50ms间隔中断，低8位赋初值
    EA = 1;                      //总中断允许位置1（EA总中断关掉，则外部中断、定时器计数器都停止）
    ET1 = 1;                     //定时器T1允许位置1
    EX0 = 1;                     //外部中断0允许位置1
    EX1 = 1;                     //外部中断1允许位置1
    IT0 = 1;                     //外部中断0启动位置1，表示下降沿启动。如果置0，则低电平启动。
    IT1 = 1;                     //外部中断1启动位置1，表示下降沿启动。
    TR1 = 1;                     //启动定时器T1，表示单片机一上电就启动定时器T1
    while (1)                    //无限循环
    {
        disp(); //此处直接调用子函数，不带变量
    }
}
