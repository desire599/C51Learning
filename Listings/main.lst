C51 COMPILER V9.60.0.0   MAIN                                                              12/07/2020 21:21:49 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //任务9-2矩阵按键-行列反转法
   2          #include <reg51.h> //包含头文件reg51.h，定义了51单片机的专用寄存器
   3          /*------宏定义及全局变量-----*/
   4          #define keyPort P0 //定义P0口名称，键盘4*4的接口
   5          #define displayPort P1 //定义P1口名称，数码管的接口
   6          sbit LOCK = P3 ^ 0; //用LED灯表示密码锁，=0时打开灯亮，=1时锁住灯灭
   7          unsigned char  keyCodeList[] = {0xee, 0xde, 0xbe, 0x7e, 0xed, 0xdd, 0xbd, 0x7d, 0xeb, 0xdb, 0xbb, 0x7b, 0x
             -e7, 0xd7, 0xb7, 0x77}; //4x4键盘码表
   8          /*------函数声明------*/
   9          void delay(unsigned int i);
  10          char key_scan(); //键盘扫描函数声明 
  11          /*------主函数------*/                                                                                 
             -                     //延时函数声明
  12          void main()                                                                                               
             -                  //主函数
  13          {
  14   1          char button; //保存按键信息，有负值，要用char型
  15   1          unsigned char pressNumber=0;//统计按下次数
  16   1          unsigned char display[] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80,0x90,0x88,0x83,0xc6,0x
             -a1,0x86,0x8e};
  17   1          //定义数组led，依次存储包括0～9,A~F的共阳极数码管显示码表
  18   1          unsigned char status[] = {0xbf, 0x8c, 0x86};//状态码“-”、“P”、“E”
  19   1          displayPort = status[0];//数码管初始为“-”
  20   1          LOCK = 1;//密码锁初始关闭
  21   1          keyPort=0xff;
  22   1          while (1)//系统循环监视
  23   1          {
  24   2              button = key_scan();//存储键盘按下的编号
  25   2              if(button==-1)//反馈值为-1，表示无任何按键按下
  26   2                  continue;//不执行下面的语句，直接开始下一轮循环
  27   2              else if(button==8)//如果是按键8按下，则密码正确
  28   2              {
  29   3                  displayPort = display[button];//数码管先显示按下的键“8”
  30   3                  delay(50000);//延时500ms
  31   3                  displayPort = status[1];//数码管显示P，表示密码正确
  32   3                  LOCK = 0;//密码锁打开
  33   3              }
  34   2              else //密码错误时
  35   2              {
  36   3                  displayPort = display[button];//数码管显示按下的键
  37   3                  delay(50000);
  38   3                  displayPort = status[2];//数码管显示E，表示密码错误
  39   3                  LOCK = 1;//密码锁依旧锁住
  40   3                  pressNumber++;//因为前面有if-continue判断，所以只有按键按下才能执行到这
             -
  41   3              } 
  42   2              if(pressNumber==3)//如果密码输错3次，则系统锁定无法使用
  43   2                 while(1);//由于仿真时一直自动循环main函数，所以写break无效，改为系统停
             -留在这里
  44   2          }
  45   1      }
  46          
  47          /*-----延时函数------*/
  48          void delay(unsigned int i)
C51 COMPILER V9.60.0.0   MAIN                                                              12/07/2020 21:21:49 PAGE 2   

  49          {
  50   1          while (i--)
  51   1              ;
  52   1      }
  53          
  54          /*-----按键扫描函数，判断哪个按键按下，返回按键编号，因为有负值所以不能用
             -unsigned char-----*/
  55          char key_scan()
  56          {
  57   1          char scan1, scan2;       //存储两次扫描的键值变量
  58   1          char keyCode, keySelect; //定义键值和返回键选值
  59   1          char i;                  //循环计数变量
  60   1          keySelect = -1;          //键选值初始为-1，表示没有按键按下
  61   1          keyPort = 0x0f;          //对矩阵键盘所接的8个引脚，其中4行写1，对其他4列写0
  62   1          scan1 = keyPort;         //读取此时的键盘状态
  63   1          if (scan1 != 0x0f)       //如果键盘不等于前面赋值，则表示有按键按下
  64   1          {
  65   2              delay(1000);       //消除按键抖动
  66   2              scan1 = keyPort;   //再次读取键盘状态，如果第一行的第一个s0按键按下，则sca
             -n1=00001110
  67   2              if (scan1 != 0x0f) //再次判断如果键盘状态改变，则表示有按键按下。
  68   2              {             
  69   3                  keyPort = 0xf0;//对行列进行反转赋值，其中行写0，列写1
  70   3                  scan2 = keyPort;//由于s0按键按下，连接其的第1列引脚会被拉低为0，变成sca
             -n2=11100000
  71   3                  keyCode = scan1 | scan2;//将两次扫描的值进行或操作，得到键盘值的扫描码
             -以便和键码表比选
  72   3                  for (i = 0; i < 16;i++) //将此时的键码与键盘码表做对比，共16个值
  73   3                  {
  74   4                      if(keyCode==keyCodeList[i])//当找到键盘码表数组的值与此时的按键键码一
             -时
  75   4                      {
  76   5                          keySelect= i; //这时候的i值，就是对应的按键编号，就是按下的那个
             -按键
  77   5                          break;
  78   5                      }
  79   4                  }
  80   3              }
  81   2          }
  82   1          return keySelect;//返回按键编号，范围在0~15之间，-1表示没有按键按下
  83   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    210    ----
   CONSTANT SIZE    =     19    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
