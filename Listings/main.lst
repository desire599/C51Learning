C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2020 15:45:01 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //任务9-2矩阵按键-行列反转法
   2          //功能：设置密码8，开机显示-，密码锁打开；输错显示E，如果输错3次则系统锁
             -
   3          #include <reg51.h> //包含头文件reg51.h，定义了51单片机的专用寄存器
   4          #include "lcd1602.h"
   5          /*------宏定义及全局变量-----*/
   6          #define keyPort P0                                                                                        
             -                      //定义P0口名称，键盘4*4的接口
   7          sbit LOCK = P2 ^ 0;                                                                                       
             -                      //用LED灯表示密码锁，=0时打开灯亮，=1时锁住灯灭
   8          unsigned char keyCodeList[] = {0xee, 0xde, 0xbe, 0x7e, 0xed, 0xdd, 0xbd, 0x7d, 0xeb, 0xdb, 0xbb, 0x7b, 0xe
             -7, 0xd7, 0xb7, 0x77}; //4x4键盘码表
   9          unsigned char password[6] = {1, 2, 3, 4, 5, 6};                                                           
             -                      //定义密码为123456
  10          unsigned char input[10] = {0};                                                                            
             -                      //定义输入密码存放数组，最多10个
  11          
  12          /*------函数声明------*/
  13          char key_scan();                            //键盘扫描函数声明
  14          void char_display(unsigned char display[]); //字符串显示函数声明
  15          void set_newPassword();                     //设置新密码
  16          /*------主函数------*/                      //延时函数声明
  17          void main()                                 //主函数
  18          {
  19   1          unsigned char i;               //定义循环变量i
  20   1          unsigned char correct;         //密码正确与否标志，=1为正确,=0为错误
  21   1          char button;                   //保存按键信息，有负值，要用char型
  22   1          unsigned char pressNumber = 0; //统计按键按下次数
  23   1          LOCK = 1;                      //密码锁初始关闭
  24   1          keyPort = 0xff;                //让按键初始为高电平
  25   1          /*------LCD初始显示password:------*/
  26   1          lcd_int(); //调用LCD初始化函数
  27   1          delay(200);
  28   1          lcd_w_cmd(0x00 + 0x80); //设置起始显示位置在第一行第0列
  29   1          delay(200);
  30   1          char_display("password:"); //调用字符串显示函数，屏幕显示password字样
  31   1          while (1)                  //系统循环监视
  32   1          {
  33   2              button = key_scan(); //存储键盘按下的编号
  34   2              if (button != -1)    //反馈值为-1，表示无任何按键按下
  35   2              {
  36   3                  if (button >= 0 && button <= 13) //把键盘按下的字母依次显示出来
  37   3                  {
  38   4                      delay(200);
  39   4                      lcd_w_cmd(0x09 + 0x80 + pressNumber); //前面9位是留给“password:”字样的，所
             -每按一次，位置往后移1位
  40   4                      if (button >= 0 && button <= 2)
  41   4                      {
  42   5                          lcd_w_dat(button + 0x30 + 1);    //数字在LCD中显示要加上0x30才是ASCII字符
             -表对应的数值
  43   5                          input[pressNumber] = button + 1; //这里特别要注意，把按键编号存入到按
             -下次数所在的下标的数组，而不能是input[button]。
  44   5                      }
  45   4                      if (button >= 4 && button <= 6)
C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2020 15:45:01 PAGE 2   

  46   4                      {
  47   5                          lcd_w_dat(button + 0x30);    //数字在LCD中显示要加上0x30才是ASCII字符表
             -应的数值
  48   5                          input[pressNumber] = button; //这里特别要注意，把按键编号存入到按下
             -数所在的下标的数组，而不能是input[button]。
  49   5                      }
  50   4                      if (button >= 8 && button <= 10)
  51   4                      {
  52   5                          lcd_w_dat(button + 0x30 - 1);    //数字在LCD中显示要加上0x30才是ASCII字符
             -表对应的数值
  53   5                          input[pressNumber] = button - 1; //这里特别要注意，把按键编号存入到按
             -下次数所在的下标的数组，而不能是input[button]。
  54   5                      }
  55   4                      if (button == 13) //数字0的显示
  56   4                      {
  57   5                          lcd_w_dat(0 + 0x30);    //数字在LCD中显示要加上0x30才是ASCII字符表对应
             -的数值
  58   5                          input[pressNumber] = 0; //这里特别要注意，把按键编号存入到按下次数
             -所在的下标的数组，而不能是input[button]。
  59   5                      }
  60   4                      pressNumber++; //按键次数加1
  61   4                  }
  62   3                  else if (button == 14) //按键编号14位为“确认键”，按下，结束密码输入进
             -判断正确与否
  63   3                  {
  64   4                      correct = 1;          //初始密码假设为正确
  65   4                      if (pressNumber != 6) //先判断输入次数是否刚好6次，如果不是，则密码
             -误
  66   4                          correct = 0;
  67   4                      else //输入次数正确后，再判断密码是否一一对应
  68   4                      {
  69   5                          for (i = 0; i < 6; i++)
  70   5                          {
  71   6                              if (input[i] != password[i]) //只要有一个没对应上，密码就错误
  72   6                              {
  73   7                                  correct = 0; //判断正确的标志变成0，表示错误
  74   7                                  break;       //跳出循环
  75   7                              }
  76   6                          }
  77   5                      }
  78   4                      if (correct == 1) //再次判断coreect标志是否为1
  79   4                      {
  80   5                          lcd_w_cmd(0x4a + 0x80); //设置显示位置在第2行第10列
  81   5                          delay(200);
  82   5                          char_display("pass"); //在第二行显示pass字样
  83   5                          LOCK = 0;             //密码锁打开
  84   5                          while (1)
  85   5                          {
  86   6                              button = key_scan();
  87   6                              if (button != -1) //如果没有按键按下，则一直等待在这里
  88   6                                  break;
  89   6                          }
  90   5                          keyPort = 0xf0;         //重新对按键进行高低电平，来判断是否有按键
             -按下
  91   5                          while (keyPort != 0xf0) //如果按键松开，keyPort=0xf0，则跳出循环
  92   5                              ;
  93   5                          if (button == 15) //按下的按键刚好是15号键，则设置新密码
  94   5                          {
  95   6                              set_newPassword();         //设置新密码
  96   6                              delay(50000);
  97   6                              lcd_w_cmd(0x01);           //清屏可以重新输入
  98   6                              lcd_w_cmd(0x00 + 0x80);    //光标重新定位到第1行第0列
C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2020 15:45:01 PAGE 3   

  99   6                              char_display("password:"); //调用字符串显示函数，屏幕显示password字
             -样
 100   6                              pressNumber = 0;           //复位按键按下的次数统计
 101   6                          }
 102   5                      }
 103   4                      else //coreect=0则密码错误
 104   4                      {
 105   5                          lcd_w_cmd(0x4a + 0x80); //设置显示位置
 106   5                          delay(200);
 107   5                          char_display("error"); //在第二行显示error字样
 108   5                          LOCK = 1;              //密码锁关闭
 109   5                          while (key_scan() == -1)
 110   5                              ; //如果没有按键按下，则一直等待在这里
 111   5                          //如果是密码错误，则继续往下执行，重新清屏再次重来
 112   5                          lcd_w_cmd(0x01);           //清屏
 113   5                          lcd_w_cmd(0x00 + 0x80);    //光标重新定位到第1行第0列
 114   5                          char_display("password:"); //调用字符串显示函数，屏幕显示password字样
 115   5                          pressNumber = 0;           //复位按键按下的次数统计
 116   5                      }
 117   4                  }
 118   3              }
 119   2          }
 120   1      }
 121          
 122          /*-----按键扫描函数，判断哪个按键按下，返回按键编号，因为有负值所以不能用
             -unsigned char-----*/
 123          char key_scan()
 124          {
 125   1          char scan1, scan2;       //存储两次扫描的键值变量
 126   1          char keyCode, keySelect; //定义键值和返回键选值
 127   1          char i;                  //循环计数变量
 128   1          keySelect = -1;          //键选值初始为-1，表示没有按键按下
 129   1          keyPort = 0x0f;          //对矩阵键盘所接的8个引脚，其中4行写1，对其他4列写0
 130   1          scan1 = keyPort;         //读取此时的键盘状态
 131   1          if (scan1 != 0x0f)       //如果键盘不等于前面赋值，则表示有按键按下
 132   1          {
 133   2              delay(1000);       //消除按键抖动
 134   2              scan1 = keyPort;   //再次读取键盘状态，如果第一行的第一个s0按键按下，则sca
             -n1=00001110
 135   2              if (scan1 != 0x0f) //再次判断如果键盘状态改变，则表示有按键按下。
 136   2              {
 137   3                  keyPort = 0xf0;          //对行列进行反转赋值，其中行写0，列写1
 138   3                  scan2 = keyPort;         //由于s0按键按下，连接其的第1列引脚会被拉低为0，
             -变成scan2=11100000
 139   3                  keyCode = scan1 | scan2; //将两次扫描的值进行或操作，得到键盘值的扫描码
             -以便和键码表比选
 140   3                  for (i = 0; i < 16; i++) //将此时的键码与键盘码表做对比，共16个值
 141   3                  {
 142   4                      if (keyCode == keyCodeList[i]) //当找到键盘码表数组的值与此时的按键键码
             -一致时
 143   4                      {
 144   5                          keySelect = i; //这时候的i值，就是对应的按键编号，就是按下的那
             -按键
 145   5                          break;
 146   5                      }
 147   4                  }
 148   3                  while (keyPort != 0xf0)
 149   3                      ; //判断按键是否松开，这样按键从按下到松开才算完成，避免重复
 150   3              }
 151   2          }
 152   1          return keySelect; //返回按键编号，范围在0~15之间，-1表示没有按键按下
 153   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2020 15:45:01 PAGE 4   

 154          
 155          /*------显示字符串文字的LCD1602函数---*/
 156          //调用方法：char_display("QING YUAN");
 157          void char_display(unsigned char display[]) //形参为字符串数组
 158          {
 159   1          unsigned char i = 0;       //循环计数变量
 160   1          while (display[i] != '\0') //只要没到字符串的最后一个元素就执行，因为字符串数
             -自动在末尾加了\0
 161   1          {
 162   2              lcd_w_dat(display[i]); //每次把单个字符串元素写入到LCD
 163   2              i++;                   //依次累加
 164   2          }
 165   1      }
 166          
 167          /*------设置新密码------*/
 168          void set_newPassword()
 169          {
 170   1          char key, count = 0;             //key存储按键编号，因为有负数，一定要char型，count
             -储按键按下次数
 171   1          lcd_w_cmd(0x01);                 //清屏
 172   1          lcd_w_cmd(0x00 + 0x80);          //光标重新定位到第1行第0列
 173   1          char_display("password setup:"); //调用字符串显示函数，屏幕显示password setup:字样
 174   1          lcd_w_cmd(0x40 + 0x80);          //显示位置设在第2行第0列
 175   1          while (1)
 176   1          {
 177   2              key = key_scan(); //读取按键编号
 178   2              if (key != -1)
 179   2              {
 180   3                  lcd_w_dat('*'); //按下后就显示*
 181   3                  if (key >= 0 && key <= 2)
 182   3                  {
 183   4                      password[count] = key + 1; //这里特别要注意，把按键编号存入到按下次数
             -在的下标的数组，而不能是input[button]。
 184   4                  }
 185   3                  if (key >= 4 && key <= 6)
 186   3                  {
 187   4                      password[count] = key; //这里特别要注意，把按键编号存入到按下次数所
             -的下标的数组，而不能是input[button]。
 188   4                  }
 189   3                  if (key >= 8 && key <= 10)
 190   3                  {
 191   4                      password[count] = key - 1; //这里特别要注意，把按键编号存入到按下次数
             -在的下标的数组，而不能是input[button]。
 192   4                  }
 193   3                  if (key == 13) //数字0的显示
 194   3                  {
 195   4                      password[count] = 0; //这里特别要注意，把按键编号存入到按下次数所在
             -下标的数组，而不能是input[button]。
 196   4                  }
 197   3                  count++; //输入密码个数累加1
 198   3                  if (count == 6)
 199   3                      break;              //输入6个密码后，就跳出循环
 200   3              }
 201   2          }
 202   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    811    ----
   CONSTANT SIZE    =     37    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2020 15:45:01 PAGE 5   

   DATA SIZE        =     32       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
