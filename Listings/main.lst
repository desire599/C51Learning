C51 COMPILER V9.60.0.0   MAIN                                                              11/27/2020 14:05:48 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //8-2ƬPCFоƬADDAת
   2          #include <reg52.h>
   3          #include <intrins.h> //nop
   4          sbit SCL = P1 ^ 7;   //I2Cʱ
   5          sbit SDA = P1 ^ 6;   //I2C
   6          bit bdata IIC_ERROR; //I2CӦ־λIIC_ERRORΪԶbdataı20H~2FHRAM16
             -byteΧɶддbdataҲԣϵͳڴռ
   7          //ʱ4΢뺯ÿnopִһڣ12MHzľ1sĻ
   8          void Delay4us()
   9          {
  10   1          _nop_();
  11   1          _nop_();
  12   1          _nop_();
  13   1          _nop_();
  14   1      }
  15          
  16          //1iic_start
  17          //ܣI2CߣI2CʼβΣޣֵ
  18          void IIC_Start()
  19          {
  20   1          SDA = 1;    //߸ߵƽ
  21   1          SCL = 1;    //ʱ߸ߵƽ
  22   1          Delay4us(); //ʼʱҪ4.7sԵʱ
  23   1          SDA = 0;    //ʱ߸ߵƽʱSDAߴӸߵƽתΪ͵ƽһ䣬I2Cͨſʼ
  24   1          Delay4us();
  25   1          SCL = 0; //λʱΪ͵ƽ޸SDAݣжд
  26   1      }
  27          
  28          //5iic_stop
  29          //ܣֹͣI2CݴͣβΣޣֵ
  30          void IIC_Stop()
  31          {
  32   1          SDA = 0;    //ߵ͵ƽ
  33   1          SCL = 1;    //ʱ߸ߵƽ
  34   1          Delay4us(); //ʼʱҪ4.7sԵʱ
  35   1          SDA = 1;    //ʱ߸ߵƽʱSDAߴӵ͵ƽתΪߵƽһ䣬I2CͨŽ
  36   1          Delay4us();
  37   1          SCL = 0; //λʱΪ͵ƽ޸SDAݣжд
  38   1      }
  39          
  40          //2IICSendByte
  41          //ܣƬһֽڣһֽ8λɣI2C豸βΣҪ͵ݡֵ
             -ޡ
  42          void IIC_SendByte(unsigned char sendData)
  43          {
  44   1          unsigned char i = 8;    //ҪSDAϷһֽݣ8λԶѭi
  45   1          for (i = 0; i < 8; i++) //ѭ8λ
  46   1          {
  47   2              SDA = (bit)(sendData & 0x80); //ʱǰIIC_startʱSCLΪ͵ƽſԷݵSDA
  48   2              //ΪSDAȴ͵λҪʣµĵ7λ0x80&㡱
  49   2              //bitΪǿƽ֮ĽתΪλΪ10SDA
  50   2              SCL = 1;        //ٰSCLΪ1SDAϵȶݵķ
  51   2              Delay4us();     //ȴ4ںȷѾ
  52   2              SCL = 0;        //λSCLΪ0һβܰݴSDA
C51 COMPILER V9.60.0.0   MAIN                                                              11/27/2020 14:05:48 PAGE 2   

  53   2              sendData <<= 1; //Ҫ͵1λ0x80㣬ʵݣ8λƣ8
             -ɷ
  54   2          }
  55   1          Delay4us();
  56   1      }
  57          
  58          //4check_ACK
  59          //ܣƬڷһݺҪȡI2C豸ӦźšβΣޡֵޡ
  60          void check_ACK()
  61          {
  62   1          SDA = 1;         //ʱI2C豸ǿΪȡ״̬ƬȡI2CӦźţSDAд1SDAд0
             -дݵPCF8591оƬ
  63   1          SCL = 1;         //ʱΪ1ȶSDAݣݶȡ
  64   1          Delay4us();      //ȴȡݵ
  65   1          IIC_ERROR = SDA; //ѴʱȡSDAźŴIIC_ERRORIIC_ERRORֵΪ1ʾӦ
             -0Ӧͨ
  66   1          SCL = 0;         //λʱΪ͵ƽ޸SDA
  67   1          Delay4us();
  68   1      }
  69          
  70          //5IICReceiveByte
  71          //ܣƬմI2CصһֽݡβΣޡֵؽյ
  72          unsigned char IIC_ReceiveByte()
  73          {
  74   1          unsigned char i = 8;       //I2C豸ҪһֽݸƬ8λԶѭ
             -i
  75   1          unsigned char receiveData; //ݵıreceiveData
  76   1          while (i--)
  77   1          {
  78   2              SDA = 1;      //ʱI2C豸ǿΪȡ״̬ƬI2CķݣSDAд1SDAд0
             -дݵPCF8591оƬ
  79   2              SCL = 1;      //ʱΪ1ȶSDAݣݶȡ
  80   2              Delay4us();   //ȴȡݵ
  81   2              if (SDA == 1) //ΪSDAÿֻܶдһλҪ8һ뵽receiveData
  82   2              {
  83   3                  receiveData = receiveData | 0x01; //յλΪ1ֻreceiveDataһλΪ1
  84   3                  //ΪI2C豸صÿδλģÿȷŵλ8
             -ξͻصλ
  85   3              }
  86   2              else
  87   2              {
  88   3                  receiveData = receiveData & 0xfe; //յλΪ0ֻreceiveDataһλΪ0
  89   3              }
  90   2              SCL = 0;                        //λʱΪ͵ƽ޸SDA
  91   2              receiveData = receiveData << 1; //ŰѴ洢ݵı1λԱ洢һݵλӶ
             -ʵλSDA߶ȡ
  92   2          }
  93   1          return receiveData;
  94   1      }
  95          
  96          //send_ACK
  97          //ܣƬյPCFоƬķֵʱӦλPCFоƬ
  98          void send_ACK()
  99          {
 100   1          SDA = 0; //һĲSCL=0ʱΪӵƬPCFоƬһSDAĵ͵ƽʾƬѾյ
             -
 101   1          SCL = 1; //ʱ1ȶݣ÷͹ȥ
 102   1          Delay4us();
 103   1          SDA = 1; //
 104   1          SCL = 0; //λʱΪ͵ƽ޸SDA
 105   1      }
 106          
C51 COMPILER V9.60.0.0   MAIN                                                              11/27/2020 14:05:48 PAGE 3   

 107          //send_NoACK
 108          //ܣƬٷ޷ӦλPCFоƬԶ
 109          void send_NoACK()
 110          {
 111   1          SDA = 1; //һĲSCL=0ʱΪӵƬPCFоƬһSDAĵ͵ƽʾƬѾյ
             -
 112   1          SCL = 1; //ʱ1ȶݣ÷͹ȥ
 113   1          Delay4us();
 114   1          SDA = 0; //
 115   1          SCL = 0; //λʱΪ͵ƽ޸SDA
 116   1      }
 117          
 118          //ȷźŸPCFоƬٶȡAIN0ͨ0ĵѹģźţADת󣬰ظƬ
 119          unsigned char ADC_PCF8591(unsigned char controlByte)
 120          {
 121   1          unsigned char idata receiveFromPCF;
 122   1          IIC_Start();               //1ͨ
 123   1          IIC_SendByte(0x90);        //2дַ
 124   1          check_ACK();               //3ÿηһֽھҪӦλ
 125   1          if (IIC_ERROR == 1)        //ӦźŵķֵжǷӦʧܣΪ1
 126   1              return 0;                //򷵻0ϵͳ
 127   1          IIC_SendByte(controlByte); //4Ϳֽ
 128   1          check_ACK();               //ÿηһֽھҪӦλ
 129   1          if (IIC_ERROR == 1)
 130   1              return 0;
 131   1          IIC_Start();        //5ͨţֶĬ0ֻͨ0ģ
 132   1          IIC_SendByte(0x91); //6Ͷַ
 133   1          check_ACK();        //ÿηһֽھҪӦλȷ
 134   1          if (IIC_ERROR == 1)
 135   1              return 0;
 136   1          receiveFromPCF = IIC_ReceiveByte(); //7õƬPCFоƬĳ򣬰Ѷȡֵ
 137   1          send_ACK();                         //8ƬӦźŸPCFоƬ
 138   1          send_NoACK();
 139   1          IIC_Stop();                         //9ֹͨ
 140   1          return receiveFromPCF;              //10PCFоƬⲿģͨ0ת
 141   1      }
 142          
 143          //һ8λDAתģ
 144          void DAC_PCF8591(unsigned char controlByte, unsigned char writeData)
 145          {
 146   1          IIC_Start();               //1ͨ
 147   1          IIC_SendByte(0x90);        //2дַ
 148   1          check_ACK();               //3ÿηһֽھҪӦλ
 149   1          if (IIC_ERROR == 1)        //ӦźŵķֵжǷӦʧܣΪ1
 150   1              return;                //򷵻0ϵͳ
 151   1          IIC_SendByte(controlByte); //4Ϳֽ
 152   1          check_ACK();               //ÿηһֽھҪӦλ
 153   1          if (IIC_ERROR == 1)
 154   1              return;
 155   1          IIC_SendByte(writeData); //5
 156   1          check_ACK();             //ÿηһֽھҪӦλ
 157   1          if (IIC_ERROR == 1)
 158   1              return;
 159   1          IIC_Stop(); //6ͨ
 160   1      }
 161          
 162          //  PCF8591ֽڽDAתݲ
 163          //
 164          void main()
 165          {
 166   1          unsigned int i;
 167   1          while (1)
C51 COMPILER V9.60.0.0   MAIN                                                              11/27/2020 14:05:48 PAGE 4   

 168   1          {
 169   2              DAC_PCF8591(0x40, ADC_PCF8591(0x00)); //ѿֵֺDAתĺ
 170   2              for(i=0;i<10000;i++);
 171   2          }
 172   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    262    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----       1
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
