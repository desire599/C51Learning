C51 COMPILER V9.60.0.0   MAIN                                                              12/07/2020 22:54:15 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //任务9-2矩阵按键-行列反转法
   2          //功能：设置密码8，开机显示-，密码锁打开；输错显示E，如果输错3次则系统锁
             -
   3          #include <reg51.h> //包含头文件reg51.h，定义了51单片机的专用寄存器
   4          #include "lcd1602.h"
   5          /*------宏定义及全局变量-----*/
   6          #define keyPort P0                                                                                        
             -                      //定义P0口名称，键盘4*4的接口
   7          sbit LOCK = P2 ^ 0;                                                                                       
             -                      //用LED灯表示密码锁，=0时打开灯亮，=1时锁住灯灭
   8          unsigned char keyCodeList[] = {0xee, 0xde, 0xbe, 0x7e, 0xed, 0xdd, 0xbd, 0x7d, 0xeb, 0xdb, 0xbb, 0x7b, 0xe
             -7, 0xd7, 0xb7, 0x77}; //4x4键盘码表
   9          unsigned char password[6] = {1, 2, 3, 4, 5, 6};                                                           
             -                      //定义密码为123456
  10          unsigned char input[10] = {0};                                                                            
             -                      //定义输入密码存放数组，最多10个
  11          
  12          /*------函数声明------*/
  13          char key_scan();       //键盘扫描函数声明
  14          /*------主函数------*/ //延时函数声明
  15          void main()            //主函数
  16          {
  17   1          unsigned char i, j;                      //定义循环变量i
  18   1          unsigned char correct = 0;               //密码正确与否标志，=1为正确
  19   1          char button;                             //保存按键信息，有负值，要用char型
  20   1          unsigned char pressNumber = 0;           //统计按下次数
  21   1          unsigned char lcdTitle1[] = "password:"; //LCD标题1
  22   1          unsigned char lcdTitle2[] = "pass";      //LCD标题2
  23   1          unsigned char lcdTitle3[] = "error";     //LCD标题3
  24   1          LOCK = 1;                                //密码锁初始关闭
  25   1          keyPort = 0xff;                          //让按键初始为高电平
  26   1          /*------LCD初始显示password:------*/
  27   1          lcd_int(); //调用LCD初始化函数
  28   1          delay(200);
  29   1          lcd_w_cmd(0x00 + 0x80); //设置起始显示位置在第一行第0列
  30   1          delay(200);
  31   1          for (i = 0; lcdTitle1[i] != '\0'; i++) //显示字符串，当字符串结束符为'\0'时，则跳出
             -for循环。
  32   1          {
  33   2              lcd_w_dat(lcdTitle1[i]);
  34   2              delay(200);
  35   2          }
  36   1          while (1) //系统循环监视
  37   1          {
  38   2              button = key_scan(); //存储键盘按下的编号
  39   2              if (button != -1)    //反馈值为-1，表示无任何按键按下
  40   2              {
  41   3                  if (button >= 0 && button <= 9) //把键盘按下的字母依次显示出来
  42   3                  {
  43   4                      input[button] = button;
  44   4                      delay(200);
  45   4                      lcd_w_dat(button + 0x30); //数字在LCD中显示要加上0x30才是ASCII字符表对应
             -数值
  46   4                      pressNumber++;
C51 COMPILER V9.60.0.0   MAIN                                                              12/07/2020 22:54:15 PAGE 2   

  47   4                  }
  48   3                  else if (button == 11) //按键11，即确认键按下，结束密码输入
  49   3                  {
  50   4                      correct = 1;
  51   4                      if (pressNumber != 6) //判断输入次数是否刚好6次，如果不是，则密码错
             -
  52   4                          correct = 0;
  53   4                      else //输入次数正确后再判断密码是否一一对应
  54   4                      {
  55   5                          for (i = 0; i < 6; i++)
  56   5                          {
  57   6                              if (input[i] != password[i]) //只要有一个没对应上，密码就错误
  58   6                              {
  59   7                                  correct = 0;
  60   7                                  break;
  61   7                              }
  62   6                          }
  63   5                      }
  64   4                      if (correct == 1)
  65   4                      {
  66   5                          lcd_w_cmd(0x4a + 0x80); //设置显示位置在第2行第10列
  67   5                          delay(200);
  68   5                          for (j = 0; lcdTitle2[j] != '\0'; j++) //显示字符串，当字符串结束符为'\0
             -'时，则跳出for循环。
  69   5                          {
  70   6                              lcd_w_dat(lcdTitle2[j]);
  71   6                              delay(200);
  72   6                          }
  73   5                      }
  74   4                  }
  75   3              }
  76   2          }
  77   1      }
  78          
  79          /*-----按键扫描函数，判断哪个按键按下，返回按键编号，因为有负值所以不能用
             -unsigned char-----*/
  80          char key_scan()
  81          {
  82   1          char scan1, scan2;       //存储两次扫描的键值变量
  83   1          char keyCode, keySelect; //定义键值和返回键选值
  84   1          char i;                  //循环计数变量
  85   1          keySelect = -1;          //键选值初始为-1，表示没有按键按下
  86   1          keyPort = 0x0f;          //对矩阵键盘所接的8个引脚，其中4行写1，对其他4列写0
  87   1          scan1 = keyPort;         //读取此时的键盘状态
  88   1          if (scan1 != 0x0f)       //如果键盘不等于前面赋值，则表示有按键按下
  89   1          {
  90   2              delay(1000);       //消除按键抖动
  91   2              scan1 = keyPort;   //再次读取键盘状态，如果第一行的第一个s0按键按下，则sca
             -n1=00001110
  92   2              if (scan1 != 0x0f) //再次判断如果键盘状态改变，则表示有按键按下。
  93   2              {
  94   3                  keyPort = 0xf0;          //对行列进行反转赋值，其中行写0，列写1
  95   3                  scan2 = keyPort;         //由于s0按键按下，连接其的第1列引脚会被拉低为0，
             -变成scan2=11100000
  96   3                  keyCode = scan1 | scan2; //将两次扫描的值进行或操作，得到键盘值的扫描码
             -以便和键码表比选
  97   3                  for (i = 0; i < 16; i++) //将此时的键码与键盘码表做对比，共16个值
  98   3                  {
  99   4                      if (keyCode == keyCodeList[i]) //当找到键盘码表数组的值与此时的按键键码
             -一致时
 100   4                      {
 101   5                          keySelect = i; //这时候的i值，就是对应的按键编号，就是按下的那
C51 COMPILER V9.60.0.0   MAIN                                                              12/07/2020 22:54:15 PAGE 3   

             -按键
 102   5                          break;
 103   5                      }
 104   4                  }
 105   3                  while (keyPort != 0xf0)
 106   3                      ; //判断按键是否松开，这样按键从按下到松开才算完成，避免重复
 107   3              }
 108   2          }
 109   1          return keySelect; //返回按键编号，范围在0~15之间，-1表示没有按键按下
 110   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    381    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     32      27
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
