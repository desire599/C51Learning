C51 COMPILER V9.60.0.0   MAIN                                                              12/30/2020 19:06:47 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //任务8-2AD转换数码管显示电压值（简易电压表）
   2          #include <reg52.h>
   3          #include <intrins.h> //包含nop函数
   4          sbit SCL = P1 ^ 7;   //I2C时钟引脚
   5          sbit SDA = P1 ^ 6;   //I2C数据输入输出引脚
   6          sbit DP = P3 ^ 7;    //定义数码管的DP引脚，即小数点引脚
   7          bit bdata IIC_ERROR; //I2C应答错误标志位，其中IIC_ERROR为自定义变量名，bdata：定义的
             -变量在20H~2FH的RAM，16byte范围，变量可读写。不写bdata也可以，由系统随机分配内存空间
   8          //定义全局数组，用于存储4个显示数码管对应的显示值
   9          unsigned char disp[4] = {0, 0, 0, 0};
  10          
  11          //延时4微秒函数。每个nop函数执行一个机器周期，所以12MHz的晶振产生1μs的机器
             -期
  12          void Delay4us()
  13          {
  14   1          _nop_();
  15   1          _nop_();
  16   1          _nop_();
  17   1          _nop_();
  18   1      }
  19          
  20          //1、函数名：iic_start
  21          //功能：启动I2C总线，即发送I2C起始条件，形参：无，返回值：无
  22          void IIC_Start()
  23          {
  24   1          SDA = 1;    //数据线高电平
  25   1          SCL = 1;    //时钟线高电平
  26   1          Delay4us(); //起始条件建立时间需要大于4.7μs，所以调用延时函数
  27   1          SDA = 0;    //在时钟线高电平时，SDA数据线从高电平转为低电平一次跳变，则I2C
             -信开始启动
  28   1          Delay4us();
  29   1          SCL = 0; //复位时钟线为低电平，这样才能允许接下来修改SDA传输的数据，进行
             -写数据
  30   1      }
  31          
  32          //5、函数名：iic_stop
  33          //功能：停止I2C总线数据传送，形参：无，返回值：无
  34          void IIC_Stop()
  35          {
  36   1          SDA = 0;    //数据线低电平
  37   1          SCL = 1;    //时钟线高电平
  38   1          Delay4us(); //起始条件建立时间需要大于4.7μs，所以调用延时函数
  39   1          SDA = 1;    //在时钟线高电平时，SDA数据线从低电平转为高电平一次跳变，则I2C
             -信结束
  40   1          Delay4us();
  41   1          SCL = 0; //复位时钟线为低电平，这样才能允许接下来修改SDA传输的数据，进行
             -写数据
  42   1      }
  43          
  44          //2、函数名：IICSendByte
  45          //函数功能：主机（即单片机）发送一个字节（一个字节由8位二进制组成）给I2C
             -备。形参：要发送的数据。返回值：无。
  46          void IIC_SendByte(unsigned char sendData)
  47          {
C51 COMPILER V9.60.0.0   MAIN                                                              12/30/2020 19:06:47 PAGE 2   

  48   1          unsigned char i = 8;    //由于要向SDA上发送一个字节数据，共8位，所以定义循环计
             -数变量i
  49   1          for (i = 0; i < 8; i++) //循环移入8位
  50   1          {
  51   2              SDA = (bit)(sendData & 0x80); //此时前面IIC_start时，SCL为低电平，这样才可以放入
             -数据到SDA
  52   2              //因为SDA首先传送的是最高位，所以要屏蔽剩下的低7位，与0x80做“&与运算
             -”
  53   2              //（bit）为强制将发送数据与运算之后的结果转换为位（即为1或0），最后
             -其存入SDA数据线
  54   2              SCL = 1;        //再把SCL设为1，让SDA数据线上的数据稳定，完成数据的发送
  55   2              Delay4us();     //等待4个机器周期后，确保已经发送完毕
  56   2              SCL = 0;        //复位SCL为0，这样下一次才能把数据存入SDA数据线中
  57   2              sendData <<= 1; //把要发送的数据左移1位，继续与0x80做与运算，这样实现逐个
             -把数据（即8位二进制）分8次完成发送
  58   2          }
  59   1          Delay4us();
  60   1      }
  61          
  62          //4、函数名：check_ACK
  63          //函数功能：主机（即单片机）在发完一节数据后要读取的I2C设备反馈的应答信
             -。形参：无。返回值：无。
  64          void check_ACK()
  65          {
  66   1          SDA = 1;         //先将数据线SDA=1，表示这个位为应答位，等待接收机PCF芯片自动
             -反馈应答信号
  67   1          SCL = 1;         //将时钟线SCL置为1，开始第9个时钟脉冲周期。
  68   1          Delay4us();      //等待读取数据的完成
  69   1          IIC_ERROR = SDA; //把此时从机通过数据线SDA反馈的应答信号存入IIC_ERROR变量，如
             -IIC_ERROR存的值为1，表示出现应答错误，如果是0，则正常应答通信
  70   1          SCL = 0;         //复位时钟线为低电平，这样才能允许接下来修改SDA传输的数据
  71   1          Delay4us();
  72   1      }
  73          
  74          //5、函数：IICReceiveByte
  75          //函数功能：主机（即单片机）接收从I2C返回的一个字节数据。形参：无。返回
             -：返回接收的数据
  76          unsigned char IIC_ReceiveByte()
  77          {
  78   1          unsigned char i = 8;       //由于I2C设备要返回一个字节数据给主机（即单片机），
             -8位，所以定义循环计数变量i
  79   1          unsigned char receiveData; //定义存放数据的变量receiveData
  80   1          while (i--)
  81   1          {
  82   2              SDA = 1;    //此时I2C设备强制设为读取状态，即单片机接收I2C的返回数据，所
             -以向SDA写入1。而SDA写入0，是写入数据到PCF8591芯片
  83   2              SCL = 1;    //将时钟线置为1，可以稳定SDA的数据，进行数据读取
  84   2              Delay4us(); //等待读取数据的完成
  85   2              //特别注意：总共8位数据，移位只能7次，不然数值会出错。
  86   2              //由于第一次执行时recevieData是0，忽略了1次，因此循环8次实际只移位了7次
             -。
  87   2              receiveData = receiveData << 1;//如果放在if-else语句的后面，则会移位8次，这样返
             -回值会出错。要先把存储接收数据的变量左移1位，以便存储下一个返回数据的位。从而实
             -逐个位来保存从SDA数据线读取的数据
  88   2              //下面是读取数据，共8位，需要8次
  89   2              if (SDA == 1) //因为数据线SDA每次只能读写一位，所以要分8次一个个存入到rec
             -eiveData变量中
  90   2              {
  91   3                  receiveData = receiveData | 0x01; //若接收到的位为1，则只把receiveData的最后一
             -设为1。
  92   3                  //因为从I2C设备返回的数据是每次从最高位传输过来的，所以主机接收
             -次先放到最低位，再用左移运算8次就回到最高位了
C51 COMPILER V9.60.0.0   MAIN                                                              12/30/2020 19:06:47 PAGE 3   

  93   3              }
  94   2              else
  95   2              {
  96   3                  receiveData = receiveData & 0xfe; //若接收到的位为0，则只把receiveData的最后一
             -设为0
  97   3              }
  98   2              SCL = 0; //复位时钟线为低电平，这样才能允许接下来修改SDA传输的数据
  99   2          }
 100   1          return receiveData;
 101   1      }
 102          
 103          //函数名：send_ACK
 104          //函数功能：单片机接收到PCF芯片的返回值时，发送应答位给PCF芯片
 105          void send_ACK()
 106          {
 107   1          SDA = 0; //由于上一步的操作SCL=0，此时人为从单片机向PCF芯片发送一个SDA的低
             -平，表示单片机已经收到数据了
 108   1          SCL = 1; //时钟线设1，稳定数据，把上面的设置发送过去
 109   1          Delay4us();
 110   1          SDA = 1; //
 111   1          SCL = 0; //复位时钟线为低电平，这样才能允许接下来修改SDA传输的数据
 112   1          Delay4us();
 113   1      }
 114          
 115          //函数名：send_NoACK
 116          //函数功能：单片机再发送无法应答位给PCF芯片，自动结束
 117          void send_NoACK()
 118          {
 119   1          SDA = 1; //从单片机发送一个高电平给PCF芯片，表示非应答，也就是无法应答自
             -结束
 120   1          SCL = 1; //时钟线设1，稳定数据，把上面的设置发送过去
 121   1          Delay4us();
 122   1          SDA = 0; //复位数据线
 123   1          SCL = 0; //复位时钟线为低电平，这样才能允许接下来修改SDA传输的数据
 124   1          Delay4us();
 125   1      }
 126          
 127          //先发送信号给PCF芯片，再读取AIN0通道0的电压模拟信号，进行AD转换后，把数字
             -返回给单片机
 128          unsigned char ADC_PCF8591(unsigned char controlByte)
 129          {
 130   1          unsigned char idata receiveFromPCF;
 131   1          IIC_Start();               //1、启动通信
 132   1          IIC_SendByte(0x90);        //2、发送写地址
 133   1          check_ACK();               //3、每次发送一个字节就要检查应答位
 134   1          if (IIC_ERROR == 1)        //根据应答信号的反馈值判断是否应答失败，如果错误变
             -为1
 135   1              return 0;              //则返回0，结束整个系统程序
 136   1          IIC_SendByte(controlByte); //4、发送控制字节0x00，即表示打开模拟量通道0进行AD转
             -
 137   1          check_ACK();               //每次发送一个字节就要检查应答位
 138   1          if (IIC_ERROR == 1)
 139   1              return 0;
 140   1          IIC_Stop();         //通信终止
 141   1          IIC_Start();        //5、重新启动通信
 142   1          IIC_SendByte(0x91); //6、发送读地址
 143   1          check_ACK();        //每次发送一个字节就要检查应答位，确保发送完毕
 144   1          if (IIC_ERROR == 1)
 145   1              return 0;
 146   1          receiveFromPCF = IIC_ReceiveByte(); //7、调用单片机接收PCF芯片的程序，把读取的数值
 147   1          send_ACK();                         //8、单片机发送应答信号给PCF芯片
 148   1          send_NoACK();                       //9、单片机发送无法应答的信号给PCF芯片，强制让
C51 COMPILER V9.60.0.0   MAIN                                                              12/30/2020 19:06:47 PAGE 4   

             -PCF芯片以为无法应答而终止通信，此句必须要有，否则返回的数字量不准确。
 149   1          IIC_Stop();                         //10、通信终止
 150   1          return receiveFromPCF;              //11、返回PCF芯片从外部模拟通道0转换过来的数字
             -
 151   1      }
 152          
 153          //数字量与电压值的数据处理函数:dataProcess
 154          //分别得到电压值的四位数存入数组disp[]中，以便数码管的显示函数进行引用
 155          void dataProcess(unsigned char digital)
 156          {
 157   1          //通道0的DA转换后返回的数字量
 158   1          unsigned int voltage; //把通道0的电压值转换过来的数字量反过来计算电压值
 159   1          voltage = 196 * digital;
 160   1          //电压与数字量成正比关系，所以得到转换公式：5V/255=voltage/digital
 161   1          //则voltage=5*digital/255=0.0196*digital
 162   1          //为了让其显示在4个数码管上，可以放大10000倍来显示，即voltage=196*digital
 163   1          disp[3] = voltage / 10000;       //因为放大了一万倍，所以先得到万位的值
 164   1          disp[2] = (voltage / 1000) % 10; //得到千位的值
 165   1          disp[1] = (voltage / 100) % 10;  //得到百位的值
 166   1          disp[0] = (voltage / 10) % 10;   //得到十位的值，个位不需要了
 167   1      }
 168          
 169          //函数功能：在4个LED上显示电压的4位数
 170          //入口参数：无
 171          //出口参数：无
 172          void display()
 173          {
 174   1          unsigned char i, j, temp;
 175   1          unsigned char code led[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
 176   1          //定义0～9显示码，共阴极数码管，即让公共端为低电平，数码管即可使用
 177   1          temp = 0x01; //借助一个变量temp来做移位操作，存放状态；0000 0001
 178   1          //因为移位运算符<<是移位后自动补0，而数码管是低电平有效，所以不能直接
             -1111 1110
 179   1          //如果直接写P2=0x01，则会在后面执行for循环第一句P2=0xff时被覆盖掉，从而无
             -实现移位循环
 180   1          for (i = 0; i < 4; i++)
 181   1          {
 182   2              P2 = 0xff & 0x0f;  // 与操作进行屏蔽高四位（要屏蔽的相应位设0），即0000 1111
             -=0x3f，让其余6位为高电平。每次必须要熄灭全部的数码管，否则动态数码管无法显示出来。
 183   2              P3 = led[disp[i]]; //传送选择led数码管数组对应的数据到P3口，显示出来。
 184   2              P2 = ~temp;        //先赋值，需要4次，对temp取反（由0000 0001变为1111 1110）后赋
             -值给P2，此时只打开第一个数码管P2.0
 185   2              if (i == 3)
 186   2                  DP = 1; //当第4个数码管显示时，则其小数点引脚DP点亮
 187   2              for (j = 0; j < 100; j++)
 188   2                  ;       //软件空循环，延时约1ms
 189   2              temp <<= 1; //移位操作只需要3次，将w的变量左移一位，0000 0010。这样第二次
             -环时，P2=~temp=1111 1101，只打开第二个数码管P2.1
 190   2                          //当for循环结束后，由于主函数有while(1)disp()，所以又重新进入disp
             -()子函数，执行temp=0x01，这样又可以重新循环而temp不会全部变成0.
 191   2          }
 192   1      }
 193          
 194          //延时函数
 195          void delay(unsigned int i)
 196          {
 197   1          while (i--)
 198   1              ;
 199   1      }
 200          //主程序
 201          void main()
 202          {
C51 COMPILER V9.60.0.0   MAIN                                                              12/30/2020 19:06:47 PAGE 5   

 203   1          unsigned char digitalData; //定义PCF芯片返回数字量的存放变量
 204   1          while (1)
 205   1          {
 206   2              digitalData = ADC_PCF8591(0x00); //对AD转换写入0x00，表示从通道0读取外部电压，
             -转换为数字量后存入digitalData变量
 207   2              dataProcess(digitalData);        //把数字量写入数据处理函数，得到显示的四位数
 208   2              display();                       //调用数码管显示函数
 209   2              delay(1000);
 210   2          }
 211   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    378    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----       1
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
